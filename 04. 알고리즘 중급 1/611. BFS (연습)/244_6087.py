'''
문제
크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다.
지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.

'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오.
레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.

레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\')을 설치해서 방향을 90도 회전시킬 수 있다.

아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '*'로 나타냈다.
왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.

7 . . . . . . .         7 . . . . . . .
6 . . . . . . C         6 . . . . . /-C
5 . . . . . . *         5 . . . . . | *
4 * * * * * . *         4 * * * * * | *
3 . . . . * . .         3 . . . . * | .
2 . . . . * . .         2 . . . . * | .
1 . C . . * . .         1 . C . . * | .
0 . . . . . . .         0 . \-------/ .
  0 1 2 3 4 5 6           0 1 2 3 4 5 6
입력
첫째 줄에 W와 H가 주어진다. (1 ≤ W, H ≤ 100)

둘째 줄부터 H개의 줄에 지도가 주어진다. 지도의 각 문자가 의미하는 것은 다음과 같다.

.: 빈 칸
*: 벽
C: 레이저로 연결해야 하는 칸
'C'는 항상 두 개이고, 레이저로 연결할 수 있는 입력만 주어진다.

출력
첫째 줄에 C를 연결하기 위해 설치해야 하는 거울 개수의 최솟값을 출력한다.

예제 입력 1 
7 8
.......
......C
......*
*****.*
....*..
....*..
.C..*..
.......
예제 출력 1 
3
'''

import sys
input = sys.stdin.readline

from collections import deque

def bfs(start, end):
    queue = deque()
    queue.append(start)
    visited[start[0]][start[1]] = True

    distance = 0
    while queue:
        # 거울을 하나씩 설치하며 갈 수 있는 경로를 탐색한다.
        for _ in range(len(queue)):
            # (y, x)에 거울이 설치된다.
            y, x = queue.popleft()
            visited[y][x] = True

            # 이번 반복에서 4방향에 대하여 갈 수 있는 칸 검사
            for dy, dx in directions:
                ny, nx = y + dy, x + dx

                # 이동하지 못하게 될 때까지 한칸한칸 큐에 밀어넣는다.
                while True:
                    # 인덱스 초과, 벽 만남, 이미 방문 시 다음 방향으로 넘어감
                    if ny < 0 or H <= ny or nx < 0 or W <= nx:
                        break
                    if board[ny][nx] == "*":
                        break
                    if visited[ny][nx]:
                        break

                    # 조건 만족 시 종료
                    if (ny, nx) == end:
                        print(distance)
                        return

                    # 검사하면서 같은 좌표가 큐에 계속 들어가는 것을 막아야 한다.
                    if (ny, nx) not in queue:
                        queue.append((ny, nx))

                    # 동일 방향으로 한 칸 이동한다.
                    ny += dy
                    nx += dx

        # 거울을 하나 더 놓는다.
        distance += 1

W, H = map(int, input().split())
board = [input().rstrip() for _ in range(H)]

# 목표 지점 C 찾기
C_coord = []
for y in range(H):
    for x in range(W):
        if board[y][x] == "C":
            C_coord.append((y, x))

# 상하좌우 변화량
directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

# [H][W]로 방문 기록 배열 저장
visited = [[False for _ in range(W)] for _ in range(H)]

# 더 위에 있던 C가 시작으로 정해짐
bfs(C_coord[0], C_coord[1])

'''
100 7
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
**************************************************************************************************.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
'''

# 잘 풀었네..