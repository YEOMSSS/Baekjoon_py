'''
문제
어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다.
예를 들어 11=32+12+12(3개 항)이다.
이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다.
이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다.
또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로,
11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.

주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)

출력
주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.

예제 입력 1 
7
예제 출력 1 
4
예제 입력 2 
1
예제 출력 2 
1
예제 입력 3 
4
예제 출력 3 
1
예제 입력 4 
11
예제 출력 4 
3
예제 입력 5 
13
예제 출력 5 
2
'''
# 굳이 dp를 쓰지 않고도 풀 수 있지 않을까?
'''
N = int(input())

answer = 0
for i in range(int(N ** 0.5) + 1, 0, -1):
    answer += N // (i ** 2)
    N %= (i ** 2)

print(answer)
'''
# 역시 틀렸다, 이렇게 쉽게 갈 리가 없지.
# 왜 틀렸는지도 알았다. 12를 생각해 봐라.
# 4 4 4로 3이 나와야하는데, 9로 먼저 나누니 9 4 1 1로 4가 나와버린다.

# 음, i제곱부터 나누기 시작할 때, i-1제곱부터 나누기 시작할 때... 다 해보고.
# dp[i]는 N = i 일때 answer가 된다.
'''
N = int(input())

dp = [N] * (N + 1)
dp[0] = 0

for i in range(1, N + 1):
    for j in range(1, int(i ** 0.5) + 1):
        dp[i] = min(dp[i], i // (j ** 2) + dp[i % (j ** 2)])

print(dp[N])
'''
# 이건 확실히 맞았다는 생각이 든다.
# 그런데, 굳이 i // (j ** 2) + dp[i % (j ** 2)] 여야 할까?
# 그냥 dp[i - (j ** 2)] + 1 이어도 되는 것 아닐까?
# i에서 j제곱을 뺀 것의 dp값을 구하고, 거기에 j제곱(1회)을 뺐으니 +1을 해준다.

N = int(input())

dp = [0] + [N] * N

for i in range(1, N + 1):
    for j in range(1, int(i ** 0.5) + 1):
        dp[i] = min(dp[i], dp[i - (j ** 2)] + 1)

print(dp[N])

# 결국 dp는 어떤 경우들이 뭘로 끝나는지를 보면 되겠다.
# 타일문제도 어떤 타일이 가장 끝에 오는지를 보고 경우들을 각각 구하고
# 이런 것도 결국 가장 끝에 제곱수를 순서대로 오게 하여 최솟값을 갱신하는 거고.
# 계단 오르는 것도 가장 마지막에 오른 계단 수에 따라 경우를 나눠보면 되고.

# 17626번 참고. 라그랑주의 증명이었다.
# 어떤 자연수는 넷 이하의 제곱수 합으로 나타내는 것이 가능하다.
# 넷 이하라는 것을 알면 브루트포스로도 풀 수 있는 정도로 난이도가 내려간다.
# 그걸 몰랐으니 dp로 풀었지, 뭐...