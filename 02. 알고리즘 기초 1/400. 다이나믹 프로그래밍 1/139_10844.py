'''
문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

예제 입력 1 
1
예제 출력 1 
9
예제 입력 2 
2
예제 출력 2 
17
'''
# 1로 시작하면 뒤에 0,2가 올수있다. 2개.
# 23456789 다 2개씩 뒤에 올 수 있지. 음, 중복인 경우가 있나?
# 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 90
# 0은 1밖에 없고 9는 8밖에 없다는 얘기를 해줬어야지..
# 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 
# 0 2 1 3 2 4 3 5 4 6 5 7 6 8 7 9 8
# dp2 1 22 33 44 55 66 77 88 9 17개
# dp3 1 2 4 4 4 4 4 4 4 1 32개 //????
# dp4 1 4 8 8 8 8 8 8 8 1 62개 //?????????
# 앞에거에 두배 하고 -2하면 된다. dp[1],dp[2]일때만빼고.
'''
num = int(input())

dp = [0] * (num + 1)
dp[1] = 9
dp[2] = 17

for i in range(3, num + 1):
    dp[i] = (2 * dp[i - 1] - 2) % 1000000000

print(dp[num])
'''
# 이게 아예 틀린 논리다 이거지.
# 당연히 틀리지. 뭐 저따위로 써놨냐.

# 다시.
# 만약 0과 9가 아닌 i로 끝나는 계단수를 찾고싶다면
# 앞에거에서 i-1으로 끝나는 거 + i+1로 끝나는거를 하면 된다.
# 만약 0으로 끝나는 계단수의 수는 앞이 1 i+1로 끝나는 애들의 수다.
# 9로 끝나는 계단수의 수는 앞이 8 i-1로 끝나는 애들만이다.
'''
num = int(input())

# dp[i][j]는 i자리 수이면서 j로 끝나는 계단수들의 개수.
dp = [[0] * 10 for _ in range(num + 1)]

dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1] # 1자리수에는 0이 미포함.

for i in range(2, num + 1):
    for j in range(10):
        if j < 9:
            dp[i][j] += dp[i - 1][j + 1]
        if j > 0:
            dp[i][j] += dp[i - 1][j - 1]
        dp[i][j] %= 1_000_000_000

answer = sum(dp[num]) % 1_000_000_000
print(answer)
'''
# 메모리를 조금 줄여볼까? 1차원 배열 두개로 쪼개보자.
'''
num = int(input())

# prev = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 실수로 1을 10개써버렸네.
prev = [0] + [1] * 9 # 안정성.
curr = [0] * 10

for _ in range(2, num + 1):
    for i in range(10):
        curr[i] = 0 # 초기화.
        if i < 9:
            curr[i] += prev[i + 1]
        if i > 0:
            curr[i] += prev[i - 1]
        curr[i] %= 1_000_000_000
    prev, curr = curr, prev # swap을 통해 얕은 복사 방지
    # prev = curr 를 썼다가는 둘이 연동되어 curr가 갱신될때 prev값도 갱신되어버린다.
print(sum(prev) % 1_000_000_000)
'''
# 배열을 하나만 써볼까.
num = int(input())

dp = [0] + [1] * 9

for _ in range(2, num + 1):
    prev = dp[:]  # 이전 상태를 복사해놓음. 읽기 전용 prev
    for j in range(10):
        dp[j] = 0
        if j > 0:
            dp[j] += prev[j - 1]
        if j < 9:
            dp[j] += prev[j + 1]
        dp[j] %= 1_000_000_000

print(sum(dp) % 1_000_000_000)
