'''
문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다.
연산을 사용하는 횟수의 최솟값을 출력하시오.

입력
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

예제 입력 1 
2
예제 출력 1 
1
예제 입력 2 
10
예제 출력 2 
3
힌트
10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.
'''

# 이제야 진짜 알고리즘 공부를 시작한 것 같다.
# 다이나믹 프로그래밍 - 그러니까 동적 계획법을 배워보자.

# 점화식을 먼저 생각해 보자. dp[i]를 i를 만드는 최소 횟수라고 하면,
# dp[i] = min(
#     dp[i - 1] + 1
#     dp[i // 2] + 1 # i가 2의 배수일 때
#     dp[i // 3] + 1 # i가 3의 배수일 때
# )

num = int(input())

dp = [0] * (num + 1) # dp[i]: i를 1로 만들기 위한 최소 연산 횟수

dp[1] = 0 # 초기값 설정

for i in range(2, num + 1): # 2부터 차례로 dp배열을 채운다.
    # 1을 빼는 경우
    dp[i] = dp[i - 1] + 1
    # 2로 나누는 경우
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1) # 1을 뺀 경우 vs 2로 나눈 경우
    # 3으로 나누는 경우
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1) # 1을 뺀 경우 vs 2로 나눈 경우의 결과 vs 3으로 나눈 경우

print(dp[num])

# 일단 타뷸레이션으로 풀었다. 숫자가 작으니 상관없지.
# 근데 10 9 3 1 을 하면 될걸 10 9 8 7 6 5 4 3 2 1 을 다 구하고 있잖아.
# 하지만 엄청 큰 수가 들어오면 비효율적이지 않을까?
# 그렇다면, 메모이제이션을 써야겠지?
'''
def dp(x, memo={}):
    if x == 1: # 1일땐 0회
        return 0
    if x in memo: # 중복 연산은 바로 불러오기기
        return memo[x]
    
    temp = dp(x - 1, memo) + 1 # 1을 빼는 경우
    if x % 2 == 0: # 1을 빼는 경우 vs 2로 나눈 경우
        temp = min(temp, dp(x // 2, memo) + 1)
    if x % 3 == 0: # 위의 결과 vs 3으로 나눈 경우
        temp = min(temp, dp(x // 3, memo) + 1)
    
    memo[x] = temp # 전부 비교한 결과를 저장(중복연산용)
    return temp # 결과를 반환

print(dp(int(input())))
'''
# 하고 나니 깨달은 건데..
# 이 코드는 결국 -1을 하는 방식으로 짜여져 있어서
# 메모이제이션과 타뷸레이션이 큰 차이가 없구나.

# 알고리즘을 보고 "어차피 전 범위 다 보겠네?" -> 타뷸레이션
# "계산할 게 몇 개 안 되는데 가지가 많이 퍼지네?" -> 메모이제이션

# 메모이제이션을 하니까 재귀 깊이가 1000을 넘으면서 그냥 좆되버리네.
# import sys
# sys.setrecursionlimit(10**6) 를 넣으면 메모리가 초과가 난다.
# 애초에 타뷸레이션으로 풀 문제였다는 거지.