'''
문제
n개의 정수로 이루어진 임의의 수열이 주어진다.
우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.
단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자.
여기서 정답은 12+21인 33이 정답이 된다.

입력
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다.
수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

출력
첫째 줄에 답을 출력한다.

예제 입력 1 
10
10 -4 3 1 5 6 -35 12 21 -1
예제 출력 1 
33
예제 입력 2 
10
2 1 -4 3 4 -4 6 5 -5 1
예제 출력 2 
14
예제 입력 3 
5
-1 -2 -3 -4 -5
예제 출력 3 
-1
'''

# dp[i] = i까지에서 만들수있는 가장큰수
# 그러면 dp[i-1]에 i번째를 더했을때 커지면 갱신하고 안커지면 그대로가면되겠네.
# 근데 연속이라? 흠...
'''
N = int(input())

nums = list(map(int, input().split()))

dp = [0] * (N + 1)

for i in range(1, N + 1):
    total = 0
    for j in range(i):
        total = max(total, sum(nums[j : i])) # 하나하나 다 더해본다.
    dp[i] = max(dp[i - 1], total)

print(dp[N])
'''
# 이래서야 dp를 쓰는 의미가 없잖아.
# 앞에서 찾은 걸 이용해서 날먹하는게 dp의 의미란 말이다.

N = int(input())

nums = list(map(int, input().split()))

dp = [0] * N

# dp[i] 는 인덱스 i인 수를 마지막으로 하는 answer의 최댓값
dp[0] = nums[0]

# 처음부터 끝까지 자신으로 끝날때 제일 큰 값들의 리스트를 만든다.
for i in range(1, N):
    # 자신이거나, 앞에거에 자신을 더하거나. 둘중에 큰거로 간다.
    dp[i] = max(nums[i], dp[i - 1] + nums[i])

print(max(dp))
