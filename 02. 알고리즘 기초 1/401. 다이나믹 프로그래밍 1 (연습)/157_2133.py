'''
문제
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.

입력
첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.

출력
첫째 줄에 경우의 수를 출력한다.

예제 입력 1 
2
예제 출력 1 
3
'''
# 2*n일 때랑은 또 다르네.
# 맨 끝에 오는 타일이 뭐냐에 따라 더하는것만으로는 뭔가 부족하다.
# n이 짝수일 때만 딱 맞게 타일을 채울 수 있다.

# n=2일 때 3. n=4일 때 11.
# n=2일때 경우는 ㅗ ㅜ = 이렇게 3가지모양이다.
# 2칸을 딱 채우는 경우들이 저거다.
# 그런데 이제 2칸을 넘어가면 칸끼리 이어질 수가 있다.
# 이어질 때 모양이 바뀔 수 있는 건 ㅗ ㅜ다. =는 모양이 바뀔 수 없다.

# 그러면 2칸이 추가될 때마다 앞에거에 *3을 일단 해줘서 이어지지 않는 경우를 구한다.
# 그리고 끝부분 경계가 일치해 ㅗ나 ㅜ가 생겨나면 경우가 하나 더 더해져야 한다.

# dp에 끝이 세로작대기가 위일때, 아래일때,  =으로 끝날 때를 각각 구해 넣자.

# 앞에거에 ㅗ ㅜ = 를 한번씩 붙여보고, 겹치면 *2, 안겹치면 *1을 해보자. =는 무조건 *1.
'''
def main():
    n = int(input())

    if n % 2 != 0:
        print(0)
        return
    else:
        n //= 2

    dp = [[0] * 3 for _ in range(n + 1)]

    dp[1] = [1, 1, 1]

    # 0일때 ㅗ 1일때 ㅜ 2일때 =
    for i in range(2, n + 1):
        dp[i][0] = dp[i - 1][0] * 2 + dp[i - 1][1] + dp[i - 1][2]
        dp[i][1] = dp[i - 1][0] + dp[i - 1][1] * 2 + dp[i - 1][2]
        dp[i][2] = sum(dp[i - 1])

    print(sum(dp[n]))

if __name__ == "__main__":
    main()
'''
# 맞았다~~~
# 그런데 최적화해보고 싶은 게 있다. ㅗ일때랑 ㅜ일때랑 값이 같아.
# 그냥 합쳐서 *3을 하고 =에 *2해주면 될듯.
'''
def main():
    n = int(input())

    if n % 2 != 0:
        print(0)
        return
    else:
        n //= 2

    dp = [[0] * 2 for _ in range(n + 1)]

    dp[1] = [2, 1]

    # 0일때 ㅗㅜ 1일때 =
    for i in range(2, n + 1):
        dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1] * 2
        dp[i][1] = sum(dp[i - 1])

    print(sum(dp[n]))

if __name__ == "__main__":
    main()
'''
# 공간최적화도 가능하겠다.

def main():
    n = int(input())

    if n % 2 != 0:
        print(0)
        return
    n //= 2

    a, b = 2, 1

    # 0일때 ㅗㅜ 1일때 =
    for _ in range(n - 1): # 이미 2,1일때 한번 실행됐으니 -1
        a, b = a * 3 + b * 2, a + b
    
    print(a + b)

if __name__ == "__main__":
    main()

# 타일이 제일 풀기 편한것같아.. 어려운걸 안해봐서 그렇겠지