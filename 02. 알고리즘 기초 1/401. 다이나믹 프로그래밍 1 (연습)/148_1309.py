'''
문제
어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다.
이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가
몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자.
사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

입력
첫째 줄에 우리의 크기 N(1 ≤ N ≤ 100,000)이 주어진다.

출력
첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

예제 입력 1 
4
예제 출력 1 
41
'''
# 한 층에 사자가 두 칸 오는 경우는 없다.
# 앞 경우에 빈칸 둘을 더하거나, 사자하나빈칸하나를 더하거나.
# N=1이면 빈빈 사빈 빈사 이렇게 3개인 것이다.
# N=2이면 빈빈 밑에 빈사 사빈 빈빈
# 사빈 밑에 빈사 빈빈, 빈사 밑에 사빈 빈빈이 올 수 있다.

# 위층에 사자가 있으면 사자가 오는경우는 하나, 위층이 빈빈이면 사빈or빈사로 둘.
# 모든 경우에 빈빈을 붙일 수 있다. 빈빈은 앞경우의 sum이다.
# 사자가 있는경우와 빈빈 즉 없는 경우를 따로 저장하면 될 듯.
'''
N = int(input())

MOD = 9901

dp = [[0, 0] for _ in range(N + 1)]
dp[1] = [1, 2]
# dp[i] = [빈빈으로 끝나는 경우, 어디든 막줄에 사자가 있는경우]

for i in range(2, N + 1):
    dp[i][0] = sum(dp[i - 1]) % MOD
    dp[i][1] = (dp[i - 1][0] * 2 + dp[i - 1][1]) % MOD

print(sum(dp[N]) % MOD)
'''
# 1차원으로 최적화. 간단하다.

N = int(input())
MOD = 9901

prev0 = 1
prev1 = 2

for _ in range(2, N + 1):
    new0 = (prev0 + prev1) % MOD
    new1 = (prev0 * 2 + prev1) % MOD
    prev0, prev1 = new0, new1

print((prev0 + prev1) % MOD)
