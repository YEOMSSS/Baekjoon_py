'''
문제
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.
어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.
예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다.
물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.

입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

예제 입력 1 
216
예제 출력 1 
198
'''
# 일단 분해합을 찾는 코드를 짜 볼까?
'''
nums = list(input())[::-1]

total = 0
for i in range(len(nums)):
    total += int(nums[i]) * 10 ** i
    total += int(nums[i])
print(total)
'''
# 이제 생성자를 찾아 보자.
# 일단 생성자는 분해합보다 무조건 작을 것이고.
# 자리마다 최대 9까지 빼질 수 있겠지.
# 분해합 - 9 * 분해합 자릿수 < 가장 작은 생성자 < 분해합.
# 범위를 그렇게 잡으면 생각보다 검사할 게 많지는 않겠다.
'''
num = int(input())
nums_split = list(str(num))

for i in range(num - len(nums_split) * 9, num):
    temp =  map(int, list(str(i)))
    if sum(temp) + i == num:
        print(i)
        break
'''
# 밥먹으니까 문제가 존나 잘풀리냐? 이거 맞는거같은데??
# 아니, 이걸 빼먹었단다. 생성자가 없는 경우에는 0을 출력한다.
# 심지어, 10 같은 경우 -9*2를 당하면 음수가 되어버린다.. 한자리 수는 대부분 그렇고..

num = int(input())
start = max(num - len(str(num)) * 9, 0)
# 자릿수가 따로따로 들어간 리스트 list(str(num))..
# 음, str도 len으로 셀 수 있잖아? list는 뺀다. str(num).
# max를 이용해 start 음수일 경우 0으로 만든다

for i in range(start, num):
    temp = map(int, list(str(i))) # map으로 저장했기에 1회만 사용가능
    if sum(temp) + i == num:
        print(i)
        break
else: # break 없이 끝난다면, 그러니까 생성자가 없다면.
    print(0)

# ✨ 코멘트
# 이 코드 수준이면 "단순 구현 문제"를 넘어서, 문제의 본질을 파악하고 효율성까지 챙기는 사고방식을 이미 갖고 계신 겁니다.
# 기초 문제를 풀면서도 이런 시야를 가지는 건 꽤 드문 일입니다.
# 난 GPT의 인정을 받은 남자다.